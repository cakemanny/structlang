#!/bin/sh

args=`getopt v $*`
if [ $? -ne 0 ]; then
    echo "usage: $0 [-v]"
    exit 2
fi
set -- $args

verbose=
while :; do
    case "$1" in
        -v)
            verbose=1
            shift
            ;;
        --)
            shift; break
            ;;
    esac
done

BUILD_DIR="$(dirname "$0")/../build/debug"
test -x "$BUILD_DIR/structlangc" || exit 1
SLC="$BUILD_DIR/structlangc"

red=$(tput setaf 1)
grn=$(tput setaf 2)
rst=$(tput sgr0)
exitcode=0

# Set defaults for the linker and its options
: "${LD=clang}"
: "${LDFLAGS=}"
: "${LDLIBS=}"

if [ -n "$verbose" ]; then
    : "${MAKE=make}"
else
    : "${MAKE=make -s}"
fi

if command -v md5sum 1>/dev/null; then
    MD5=md5sum
else
    MD5=md5
fi

SLC_HASH=$(cat $SLC | $MD5 | awk '{ print $1 }')

expect () {
    code="$1"
    expected="$2"

    code_hash=$(echo "$code" | $MD5 | awk '{ print $1 }')
    code_d=$BUILD_DIR/tests/${code_hash}
    mkdir -p "${code_d}"
    ctmp="${code_d}/test.sl"
    test -f ${ctmp} || echo "$code" > ${ctmp}
    stmp="${code_d}/test.s"
    atmp="${code_d}/a.out"

    # Tell make how to produce our assembly code
    # structlangc .../test.sl -o .../test.s
    if (printf '%s: %s %s\n\t%s $< -o $@\n' "$stmp" "$ctmp" "$SLC" "$SLC" | $MAKE -f -); then
        # Link
        # $LD $LDFLAGS $stmp -o $atmp $LDLIBS
        printf '%s: %s\n\t%s %s $< -o $@ %s\n' "$atmp" "$stmp" "$LD" "$LDFLAGS" "$LDLIBS" | $MAKE -f -

        # Run
        (cd ${code_d} && sh -c './a.out; echo $? > test.result')

        result=$(cat ${code_d}/test.result)
        if [ "$result" = "$expected" ]; then
            if [ -n "$verbose" ]; then
                echo "${grn}pass${rst}: '$code'"
            else
                echo "${grn}pass${rst}: $(echo "$code" | tr $'\n' $' ')"
            fi
        else
            echo "${red}FAIL:${rst} '$code'"
            echo "  expected: '$expected'"
            echo "  actual:   '$result'"
            exitcode=$((1 + $exitcode))
        fi
    else
        echo "${red}FAILED${rst} to compile '$code'"
        exitcode=$((1 + $exitcode))
    fi
}

# The tests

expect 'fn main() -> int { let a: int = 0; a }' '0'
expect 'fn main() -> int { let a: int = 1; a }' '1'
expect 'fn main() -> int { let a: int = -3; a }' '253'
expect 'fn main() -> int { let a: int = 1; let b: int = 2; a + b }' '3'
expect 'fn main() -> int { let a: int = 1; let b: int = 2; a - b }' '255'
expect "fn main() -> bool { true }" '1'
expect "fn main() -> bool { false }" '0'

# Arithmetic
expect 'fn main() -> int { 1 << 2; 2 >> 1 }' 1
expect 'fn main() -> int { 2 / 2 }' 1
expect 'fn main() -> int { 4 / 2 }' 2

# Logic
expect 'fn main() -> bool { true && true }' 1
expect 'fn main() -> bool { false || false }' 0
expect 'fn main() -> bool { 1 < 2 }' 1
expect 'fn main() -> bool { 1 <= 2 }' 1
expect 'fn main() -> bool { 1 > 2 }' 0
expect 'fn main() -> bool { 1 >= 2 }' 0
expect 'fn main() -> bool { 1 == 2 }' 0
expect 'fn main() -> bool { 1 != 2 }' 1
expect 'fn main() -> bool { true == true }' 1

# Allocated data
expect 'struct X { x: int }
fn main() -> bool {
    (new X{1}) == (new X{1})
}' 0

expect '
struct X { x: int }
fn main() -> bool {
    *(new X{5}) == *(new X{5})
}
' 1

# Test loading of single adjacent bytes
expect '
struct X {
    a: bool,
    b: bool,
    c: bool,
    d: bool,
}

fn main() -> int {
    let x: *X = new X { false, true, false, true };
    if (x->a && x->c) {
        5
    } else {
        10
    }
}
' 10


# Calls
expect 'fn f() -> int { 5 }
fn main() -> int { f() }' '5'

expect 'fn f(x: int) -> int { x }
fn main() -> int { f(5) }' '5'

# Conditionals
expect 'fn main() -> int { if 1 < 2 { 1 } else { 2 } }' '1'
#   I think this one is just random
#   TODO: rewrite main to always return int
expect 'fn main() -> void { if 1 < 2 { return } }' 1

exit ${exitcode}
